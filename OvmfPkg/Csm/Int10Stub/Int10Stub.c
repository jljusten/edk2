/** @file
  Installs an INT 10 stub which allows some UEFI OS's with a legacy INT 10
  dependency to boot.

  Copyright (c) 2013 - 2014, Intel Corporation. All rights reserved.<BR>

  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#include <PiDxe.h>

#include <Library/DebugLib.h>
#include <Library/BaseMemoryLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/UefiLib.h>

STATIC BOOLEAN mInstallTried = FALSE;

STATIC UINT16 mInt10CodeOffset = 0x3;

//
// Code generated by Int10Stub.asm
//
// Running the Int10Stub.sh script will output this array.
//
STATIC UINT8 mInt10StubCode[] = {
  0x55, 0xaa, 0x01, 0xeb, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x42,
  0x4d, 0x00, 0x90, 0x90, 0x50, 0x43, 0x49, 0x52, 0x13, 0x10, 0xb8, 0x00, 0x00, 0x00, 0x18, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0xe8, 0xbe, 0x00, 0x80,
  0xfc, 0x4f, 0x75, 0x16, 0x3c, 0x00, 0x74, 0x18, 0x3c, 0x01, 0x74, 0x43, 0x3c, 0x02, 0x0f, 0x84,
  0x86, 0x00, 0x3c, 0x03, 0x0f, 0x84, 0x8b, 0x00, 0xb0, 0x4f, 0xb4, 0x00, 0xcf, 0xb4, 0x01, 0xcf,
  0x51, 0x53, 0xb9, 0x14, 0x00, 0x2e, 0x8d, 0x1e, 0x71, 0x00, 0xe8, 0x7c, 0x00, 0x5b, 0x59, 0xeb,
  0xe7, 0x56, 0x45, 0x53, 0x41, 0x00, 0x02, 0x85, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x8b,
  0x00, 0x00, 0xc0, 0x24, 0x00, 0x49, 0x6e, 0x74, 0x65, 0x6c, 0x00, 0x18, 0x01, 0xff, 0xff, 0x81,
  0xf9, 0x18, 0x01, 0x75, 0xc8, 0x51, 0x53, 0xb9, 0x32, 0x00, 0x2e, 0x8d, 0x1e, 0xa6, 0x00, 0xe8,
  0x47, 0x00, 0x5b, 0x59, 0xeb, 0xb2, 0xfb, 0x00, 0x07, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x04, 0x00, 0x03, 0x08, 0x0a, 0x01, 0x18,
  0x01, 0x06, 0x00, 0x03, 0x00, 0x08, 0x10, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0xfb, 0x18, 0x01, 0x0f, 0x85, 0x7d, 0xff,
  0xe9, 0x75, 0xff, 0xbb, 0x18, 0x01, 0xe9, 0x6f, 0xff, 0x53, 0x57, 0x2e, 0x8d, 0x1e, 0x71, 0x00,
  0x2e, 0x8a, 0x07, 0x43, 0x26, 0x88, 0x05, 0x47, 0xe2, 0xf6, 0x5f, 0x5b, 0xc3, 0x56, 0x1e, 0x50,
  0x8c, 0xce, 0x8e, 0xde, 0xbe, 0x2d, 0x01, 0xe8, 0x3a, 0x00, 0xe8, 0x58, 0x00, 0xbe, 0x37, 0x01,
  0xe8, 0x31, 0x00, 0x89, 0xd8, 0xe8, 0x4d, 0x00, 0xbe, 0x3c, 0x01, 0xe8, 0x26, 0x00, 0x89, 0xc8,
  0xe8, 0x42, 0x00, 0xbe, 0x41, 0x01, 0xe8, 0x1b, 0x00, 0x58, 0x1f, 0x5e, 0xc3, 0x49, 0x4e, 0x54,
  0x31, 0x30, 0x20, 0x41, 0x58, 0x3d, 0x00, 0x20, 0x42, 0x58, 0x3d, 0x00, 0x20, 0x43, 0x58, 0x3d,
  0x00, 0x0d, 0x0a, 0x00, 0x60, 0xba, 0x02, 0x04, 0xac, 0x3c, 0x00, 0x74, 0x03, 0xee, 0xeb, 0xf8,
  0x61, 0xc3, 0x60, 0xba, 0x02, 0x04, 0x24, 0x0f, 0x3c, 0x09, 0x7f, 0x04, 0x04, 0x30, 0xeb, 0x02,
  0x04, 0x37, 0xee, 0x61, 0xc3, 0x50, 0xc1, 0xc0, 0x04, 0xe8, 0xe6, 0xff, 0xc1, 0xc0, 0x04, 0xe8,
  0xe0, 0xff, 0xc1, 0xc0, 0x04, 0xe8, 0xda, 0xff, 0xc1, 0xc0, 0x04, 0xe8, 0xd4, 0xff, 0x58, 0xc3,
};

#pragma pack (1)
typedef struct {
  UINT16 Offset;
  UINT16 Segment;
} LEGACY16_INTERRUPT_VECTOR;
#pragma pack ()

STATIC LEGACY16_INTERRUPT_VECTOR *mInt10Vec = &((LEGACY16_INTERRUPT_VECTOR*) NULL)[0x10];

/**
  Install a stub implementation of the legacy VBIOS INT 0x10.

  Some UEFI OS's still rely upon this legacy functionality.

**/
STATIC
VOID
InstallInt10Stub (
  VOID
  )
{
  EFI_STATUS            Status;
  EFI_PHYSICAL_ADDRESS  Addr;
  UINT16                Int10Segment = 0xc000;
  UINT8                 *Int10CodeDst = (UINT8*) ((UINTN) Int10Segment << 4);

  if (mInstallTried) {
    return;
  }

  mInstallTried = TRUE;

  if (mInt10Vec->Segment >= 0xc000 && mInt10Vec->Segment <= 0xffff &&
      *(UINT16*) (((UINTN) mInt10Vec->Segment) << 4) == 0xaa55) {
    //
    // It looks like someone has already installed INT 0x10.
    //
    // We may have a CSM enabled firmware that has run the
    // legacy VBIOS, so in that case the INT 0x10 stub is
    // not needed.
    //
    return;
  }

  //
  // Copy INT 0x10 stub code into the legacy location
  //
  CopyMem (Int10CodeDst, mInt10StubCode, sizeof (mInt10StubCode));

  //
  // Set INT 0x10 in the Interrupt Vector Table to point at the
  // stub entry point.
  //
  mInt10Vec->Segment = Int10Segment;
  mInt10Vec->Offset = mInt10CodeOffset;

  //
  // Try to allocate the IVT page at address 0. If it fails, then
  // Legacy BIOS DXE probably has already allocated it.
  //
  Addr = 0;
  Status = gBS->AllocatePages (
                  AllocateAddress,
                  EfiBootServicesCode,
                  1,
                  &Addr
                  );

  DEBUG((EFI_D_INFO, "Int10Stub installed\n", *(UINT16*) 0x40, *(UINT16*) 0x42));
}

/**
  Notification function of EVT_GROUP_READY_TO_BOOT event group.

  Installs the INT 0x10 stub at the ReadyToBoot event.

  @param  Event        Event whose notification function is being invoked.
  @param  Context      Pointer to the notification function's context.

**/
STATIC
VOID
EFIAPI
OnReadyToBoot (
  EFI_EVENT                               Event,
  VOID                                    *Context
  )
{
  InstallInt10Stub ();
}

/**
  The constructor function for Int10Stub

  @retval EFI_SUCCESS   The constructor always returns RETURN_SUCCESS.

**/
EFI_STATUS
EFIAPI
Int10StubConstructor (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  EFI_STATUS    Status;
  EFI_EVENT     ReadyToBootEvent;

  //
  // Initialize Interrupt Vector Table entry 0x10 to 'NULL'
  //
  // During BDS, the Legacy BIOS DXE may load a legacy VBIOS.
  // If this happens we will be able to detect that a VBIOS
  // has been installed. (See code in InstallInt10Stub.)
  //
  mInt10Vec->Segment = 0;
  mInt10Vec->Offset = 0;

  //
  // We will install the INT 0x10 stub when ReadyToBoot is signalled.
  //
  Status = EfiCreateEventReadyToBootEx (
             TPL_NOTIFY, 
             OnReadyToBoot, 
             NULL, 
             &ReadyToBootEvent
             );
  ASSERT_EFI_ERROR (Status);

  return EFI_SUCCESS;
}
